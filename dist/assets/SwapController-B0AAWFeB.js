import{cP as d,cQ as B,cR as D,cS as p,cT as T,cU as P,cV as m,cW as I,cX as h,cY as y,cZ as k,c_ as f,c$ as b,d0 as A,d1 as M,d2 as F,d3 as C,d4 as L,d5 as _,d6 as W,d7 as G}from"./index-RD9we72E.js";const g={getGasPriceInEther(n,o){const t=o*n;return Number(t)/1e18},getGasPriceInUSD(n,o,t){const a=g.getGasPriceInEther(o,t);return d.bigNumber(n).times(a).toNumber()},getPriceImpact({sourceTokenAmount:n,sourceTokenPriceInUSD:o,toTokenPriceInUSD:t,toTokenAmount:a}){const i=d.bigNumber(n).times(o),r=d.bigNumber(a).times(t);return i.minus(r).div(i).times(100).toNumber()},getMaxSlippage(n,o){const t=d.bigNumber(n).div(100);return d.multiply(o,t).toNumber()},getProviderFee(n,o=.0085){return d.bigNumber(n).times(o).toString()},isInsufficientNetworkTokenForGas(n,o){const t=o||"0";return d.bigNumber(n).eq(0)?!0:d.bigNumber(d.bigNumber(t)).gt(n)},isInsufficientSourceTokenForSwap(n,o,t){const a=t?.find(r=>r.address===o)?.quantity?.numeric;return d.bigNumber(a||"0").lt(n)}},U=15e4,O=6,l={initializing:!1,initialized:!1,loadingPrices:!1,loadingQuote:!1,loadingApprovalTransaction:!1,loadingBuildTransaction:!1,loadingTransaction:!1,switchingTokens:!1,fetchError:!1,approvalTransaction:void 0,swapTransaction:void 0,transactionError:void 0,sourceToken:void 0,sourceTokenAmount:"",sourceTokenPriceInUSD:0,toToken:void 0,toTokenAmount:"",toTokenPriceInUSD:0,networkPrice:"0",networkBalanceInUSD:"0",networkTokenSymbol:"",inputError:void 0,slippage:C.CONVERT_SLIPPAGE_TOLERANCE,tokens:void 0,popularTokens:void 0,suggestedTokens:void 0,foundTokens:void 0,myTokensWithBalance:void 0,tokensPriceMap:{},gasFee:"0",gasPriceInUSD:0,priceImpact:void 0,maxSlippage:void 0,providerFee:void 0},e=D({...l}),S={state:e,subscribe(n){return G(e,()=>n(e))},subscribeKey(n,o){return W(e,n,o)},getParams(){const n=k.state.activeChain,o=k.getAccountData(n)?.caipAddress??k.state.activeCaipAddress,t=b.getPlainAddress(o),a=L(),i=_.getConnectorId(k.state.activeChain);if(!t)throw new Error("No address found to swap the tokens from.");const r=!e.toToken?.address||!e.toToken?.decimals,c=!e.sourceToken?.address||!e.sourceToken?.decimals||!d.bigNumber(e.sourceTokenAmount).gt(0),u=!e.sourceTokenAmount;return{networkAddress:a,fromAddress:t,fromCaipAddress:o,sourceTokenAddress:e.sourceToken?.address,toTokenAddress:e.toToken?.address,toTokenAmount:e.toTokenAmount,toTokenDecimals:e.toToken?.decimals,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:e.sourceToken?.decimals,invalidToToken:r,invalidSourceToken:c,invalidSourceTokenAmount:u,availableToSwap:o&&!r&&!c&&!u,isAuthConnector:i===m.CONNECTOR_ID.AUTH}},async setSourceToken(n){if(!n){e.sourceToken=n,e.sourceTokenAmount="",e.sourceTokenPriceInUSD=0;return}e.sourceToken=n,await s.setTokenPrice(n.address,"sourceToken")},setSourceTokenAmount(n){e.sourceTokenAmount=n},async setToToken(n){if(!n){e.toToken=n,e.toTokenAmount="",e.toTokenPriceInUSD=0;return}e.toToken=n,await s.setTokenPrice(n.address,"toToken")},setToTokenAmount(n){e.toTokenAmount=n?d.toFixed(n,O):""},async setTokenPrice(n,o){let t=e.tokensPriceMap[n]||0;t||(e.loadingPrices=!0,t=await s.getAddressPrice(n)),o==="sourceToken"?e.sourceTokenPriceInUSD=t:o==="toToken"&&(e.toTokenPriceInUSD=t),e.loadingPrices&&(e.loadingPrices=!1),s.getParams().availableToSwap&&!e.switchingTokens&&s.swapTokens()},async switchTokens(){if(!(e.initializing||!e.initialized||e.switchingTokens)){e.switchingTokens=!0;try{const n=e.toToken?{...e.toToken}:void 0,o=e.sourceToken?{...e.sourceToken}:void 0,t=n&&e.toTokenAmount===""?"1":e.toTokenAmount;s.setSourceTokenAmount(t),s.setToTokenAmount(""),await s.setSourceToken(n),await s.setToToken(o),e.switchingTokens=!1,s.swapTokens()}catch(n){throw e.switchingTokens=!1,n}}},resetState(){e.myTokensWithBalance=l.myTokensWithBalance,e.tokensPriceMap=l.tokensPriceMap,e.initialized=l.initialized,e.initializing=l.initializing,e.switchingTokens=l.switchingTokens,e.sourceToken=l.sourceToken,e.sourceTokenAmount=l.sourceTokenAmount,e.sourceTokenPriceInUSD=l.sourceTokenPriceInUSD,e.toToken=l.toToken,e.toTokenAmount=l.toTokenAmount,e.toTokenPriceInUSD=l.toTokenPriceInUSD,e.networkPrice=l.networkPrice,e.networkTokenSymbol=l.networkTokenSymbol,e.networkBalanceInUSD=l.networkBalanceInUSD,e.inputError=l.inputError},resetValues(){const{networkAddress:n}=s.getParams(),o=e.tokens?.find(t=>t.address===n);s.setSourceToken(o),s.setToToken(void 0)},getApprovalLoadingState(){return e.loadingApprovalTransaction},clearError(){e.transactionError=void 0},async initializeState(){if(!e.initializing){if(e.initializing=!0,!e.initialized)try{await s.fetchTokens(),e.initialized=!0}catch{e.initialized=!1,T.showError("Failed to initialize swap"),p.goBack()}e.initializing=!1}},async fetchTokens(){const{networkAddress:n}=s.getParams();await s.getNetworkTokenPrice(),await s.getMyTokensWithBalance();const o=e.myTokensWithBalance?.find(t=>t.address===n);o&&(e.networkTokenSymbol=o.symbol,s.setSourceToken(o),s.setSourceTokenAmount("0"))},async getTokenList(){const n=k.state.activeCaipNetwork?.caipNetworkId;if(!(e.caipNetworkId===n&&e.tokens))try{e.tokensLoading=!0;const o=await A.getTokenList(n);e.tokens=o,e.caipNetworkId=n,e.popularTokens=o.sort((c,u)=>c.symbol<u.symbol?-1:c.symbol>u.symbol?1:0);const a=(n&&C.SUGGESTED_TOKENS_BY_CHAIN?.[n]||[]).map(c=>o.find(u=>u.symbol===c)).filter(c=>!!c),r=(C.SWAP_SUGGESTED_TOKENS||[]).map(c=>o.find(u=>u.symbol===c)).filter(c=>!!c).filter(c=>!a.some(u=>u.address===c.address));e.suggestedTokens=[...a,...r]}catch{e.tokens=[],e.popularTokens=[],e.suggestedTokens=[]}finally{e.tokensLoading=!1}},async getAddressPrice(n){const o=e.tokensPriceMap[n];if(o)return o;const a=(await f.fetchTokenPrice({addresses:[n]}))?.fungibles||[],r=[...e.tokens||[],...e.myTokensWithBalance||[]]?.find(w=>w.address===n)?.symbol,c=a.find(w=>w.symbol.toLowerCase()===r?.toLowerCase())?.price||0,u=parseFloat(c.toString());return e.tokensPriceMap[n]=u,u},async getNetworkTokenPrice(){const{networkAddress:n}=s.getParams(),t=(await f.fetchTokenPrice({addresses:[n]}).catch(()=>(T.showError("Failed to fetch network token price"),{fungibles:[]}))).fungibles?.[0],a=t?.price.toString()||"0";e.tokensPriceMap[n]=parseFloat(a),e.networkTokenSymbol=t?.symbol||"",e.networkPrice=a},async getMyTokensWithBalance(n){const o=await F.getMyTokensWithBalance(n),t=A.mapBalancesToSwapTokens(o);t&&(await s.getInitialGasPrice(),s.setBalances(t))},setBalances(n){const{networkAddress:o}=s.getParams(),t=k.state.activeCaipNetwork;if(!t)return;const a=n.find(i=>i.address===o);n.forEach(i=>{e.tokensPriceMap[i.address]=i.price||0}),e.myTokensWithBalance=n.filter(i=>i.address.startsWith(t.caipNetworkId)),e.networkBalanceInUSD=a?d.multiply(a.quantity.numeric,a.price).toString():"0"},async getInitialGasPrice(){const n=await A.fetchGasPrice();if(!n)return{gasPrice:null,gasPriceInUSD:null};switch(k.state?.activeCaipNetwork?.chainNamespace){case m.CHAIN.SOLANA:return e.gasFee=n.standard??"0",e.gasPriceInUSD=d.multiply(n.standard,e.networkPrice).div(1e9).toNumber(),{gasPrice:BigInt(e.gasFee),gasPriceInUSD:Number(e.gasPriceInUSD)};case m.CHAIN.EVM:default:const o=n.standard??"0",t=BigInt(o),a=BigInt(U),i=g.getGasPriceInUSD(e.networkPrice,a,t);return e.gasFee=o,e.gasPriceInUSD=i,{gasPrice:t,gasPriceInUSD:i}}},async swapTokens(){const n=k.getAccountData()?.address,o=e.sourceToken,t=e.toToken,a=d.bigNumber(e.sourceTokenAmount).gt(0);if(a||s.setToTokenAmount(""),!t||!o||e.loadingPrices||!a||!n)return;e.loadingQuote=!0;const i=d.bigNumber(e.sourceTokenAmount).times(10**o.decimals).round(0);try{const r=await f.fetchSwapQuote({userAddress:n,from:o.address,to:t.address,gasPrice:e.gasFee,amount:i.toString()});e.loadingQuote=!1;const c=r?.quotes?.[0]?.toAmount;if(!c){M.open({displayMessage:"Incorrect amount",debugMessage:"Please enter a valid amount"},"error");return}const u=d.bigNumber(c).div(10**t.decimals).toString();s.setToTokenAmount(u),s.hasInsufficientToken(e.sourceTokenAmount,o.address)?e.inputError="Insufficient balance":(e.inputError=void 0,s.setTransactionDetails())}catch(r){const c=await A.handleSwapError(r);e.loadingQuote=!1,e.inputError=c||"Insufficient balance"}},async getTransaction(){const{fromCaipAddress:n,availableToSwap:o}=s.getParams(),t=e.sourceToken,a=e.toToken;if(!(!n||!o||!t||!a||e.loadingQuote))try{e.loadingBuildTransaction=!0;const i=await A.fetchSwapAllowance({userAddress:n,tokenAddress:t.address,sourceTokenAmount:e.sourceTokenAmount,sourceTokenDecimals:t.decimals});let r;return i?r=await s.createSwapTransaction():r=await s.createAllowanceTransaction(),e.loadingBuildTransaction=!1,e.fetchError=!1,r}catch{p.goBack(),T.showError("Failed to check allowance"),e.loadingBuildTransaction=!1,e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},async createAllowanceTransaction(){const{fromCaipAddress:n,sourceTokenAddress:o,toTokenAddress:t}=s.getParams();if(!(!n||!t)){if(!o)throw new Error("createAllowanceTransaction - No source token address found.");try{const a=await f.generateApproveCalldata({from:o,to:t,userAddress:n}),i=b.getPlainAddress(a.tx.from);if(!i)throw new Error("SwapController:createAllowanceTransaction - address is required");const r={data:a.tx.data,to:i,gasPrice:BigInt(a.tx.eip155.gasPrice),value:BigInt(a.tx.value),toAmount:e.toTokenAmount};return e.swapTransaction=void 0,e.approvalTransaction={data:r.data,to:r.to,gasPrice:r.gasPrice,value:r.value,toAmount:r.toAmount},{data:r.data,to:r.to,gasPrice:r.gasPrice,value:r.value,toAmount:r.toAmount}}catch{p.goBack(),T.showError("Failed to create approval transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}}},async createSwapTransaction(){const{networkAddress:n,fromCaipAddress:o,sourceTokenAmount:t}=s.getParams(),a=e.sourceToken,i=e.toToken;if(!o||!t||!a||!i)return;const r=P.parseUnits(t,a.decimals)?.toString();try{const c=await f.generateSwapCalldata({userAddress:o,from:a.address,to:i.address,amount:r,disableEstimate:!0}),u=a.address===n,w=BigInt(c.tx.eip155.gas),v=BigInt(c.tx.eip155.gasPrice),N=b.getPlainAddress(c.tx.to);if(!N)throw new Error("SwapController:createSwapTransaction - address is required");const E={data:c.tx.data,to:N,gas:w,gasPrice:v,value:BigInt(u?r??"0":"0"),toAmount:e.toTokenAmount};return e.gasPriceInUSD=g.getGasPriceInUSD(e.networkPrice,w,v),e.approvalTransaction=void 0,e.swapTransaction=E,E}catch{p.goBack(),T.showError("Failed to create transaction"),e.approvalTransaction=void 0,e.swapTransaction=void 0,e.fetchError=!0;return}},onEmbeddedWalletApprovalSuccess(){T.showLoading("Approve limit increase in your wallet"),p.replace("SwapPreview")},async sendTransactionForApproval(n){const{fromAddress:o,isAuthConnector:t}=s.getParams();e.loadingApprovalTransaction=!0,t?p.pushTransactionStack({onSuccess:s.onEmbeddedWalletApprovalSuccess}):T.showLoading("Approve limit increase in your wallet");try{await P.sendTransaction({address:o,to:n.to,data:n.data,value:n.value,chainNamespace:m.CHAIN.EVM}),await s.swapTokens(),await s.getTransaction(),e.approvalTransaction=void 0,e.loadingApprovalTransaction=!1}catch(i){const r=i;e.transactionError=r?.displayMessage,e.loadingApprovalTransaction=!1,T.showError(r?.displayMessage||"Transaction error"),I.sendEvent({type:"track",event:"SWAP_APPROVAL_ERROR",properties:{message:r?.displayMessage||r?.message||"Unknown",network:k.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:h(m.CHAIN.EVM)===y.ACCOUNT_TYPES.SMART_ACCOUNT}})}},async sendTransactionForSwap(n){if(!n)return;const{fromAddress:o,toTokenAmount:t,isAuthConnector:a}=s.getParams();e.loadingTransaction=!0;const i=`Swapping ${e.sourceToken?.symbol} to ${d.formatNumberToLocalString(t,3)} ${e.toToken?.symbol}`,r=`Swapped ${e.sourceToken?.symbol} to ${d.formatNumberToLocalString(t,3)} ${e.toToken?.symbol}`;a?p.pushTransactionStack({onSuccess(){p.replace("Account"),T.showLoading(i),S.resetState()}}):T.showLoading("Confirm transaction in your wallet");try{const c=[e.sourceToken?.address,e.toToken?.address].join(","),u=await P.sendTransaction({address:o,to:n.to,data:n.data,value:n.value,chainNamespace:m.CHAIN.EVM});return e.loadingTransaction=!1,T.showSuccess(r),I.sendEvent({type:"track",event:"SWAP_SUCCESS",properties:{network:k.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:h(m.CHAIN.EVM)===y.ACCOUNT_TYPES.SMART_ACCOUNT}}),S.resetState(),a||p.replace("Account"),S.getMyTokensWithBalance(c),u}catch(c){const u=c;e.transactionError=u?.displayMessage,e.loadingTransaction=!1,T.showError(u?.displayMessage||"Transaction error"),I.sendEvent({type:"track",event:"SWAP_ERROR",properties:{message:u?.displayMessage||u?.message||"Unknown",network:k.state.activeCaipNetwork?.caipNetworkId||"",swapFromToken:s.state.sourceToken?.symbol||"",swapToToken:s.state.toToken?.symbol||"",swapFromAmount:s.state.sourceTokenAmount||"",swapToAmount:s.state.toTokenAmount||"",isSmartAccount:h(m.CHAIN.EVM)===y.ACCOUNT_TYPES.SMART_ACCOUNT}});return}},hasInsufficientToken(n,o){return g.isInsufficientSourceTokenForSwap(n,o,e.myTokensWithBalance)},setTransactionDetails(){const{toTokenAddress:n,toTokenDecimals:o}=s.getParams();!n||!o||(e.gasPriceInUSD=g.getGasPriceInUSD(e.networkPrice,BigInt(e.gasFee),BigInt(U)),e.priceImpact=g.getPriceImpact({sourceTokenAmount:e.sourceTokenAmount,sourceTokenPriceInUSD:e.sourceTokenPriceInUSD,toTokenPriceInUSD:e.toTokenPriceInUSD,toTokenAmount:e.toTokenAmount}),e.maxSlippage=g.getMaxSlippage(e.slippage,e.toTokenAmount),e.providerFee=g.getProviderFee(e.sourceTokenAmount))}},s=B(S);export{s as S};
